// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.UMLClassDiagram = (function() {
    var IGNORED_CLASSES;

    IGNORED_CLASSES = ["UMLClassDiagram", "log", "reload", "GetIsInstalled", "GetDetails", "GetDetailsForFrame", "GetRunningState", "getInstallState", "bound", "Window", "Location", "Object", "SpeechSynthesis", "Storage", "ApplicationCache", "DeprecatedStorageInfo", "IDBFactory", "Crypto", "CSS", "Performance", "Console", "StyleMedia", "Navigator", "BarProp", "History", "Screen", "Function", "HTMLDocument", "Number", "String", "Array", "Boolean", "g", "__edges", "_inEdges", "_nextId", "_nodes", "_outEdges", "_value", "BlurStack", "stackBlurCanvasRGBA", "stackBlurCanvasRGB", "header", "mimeType", "responseType", "response", "get", "post", "send", "abort", "on"];

    function UMLClassDiagram(config) {
      var classes, clss, key, objects, val, _ref;
      this.config = {
        attributes: true,
        methods: true,
        "arguments": true,
        returnTypes: true,
        types: true,
        cardinalities: true
      };
      if (config instanceof Object) {
        for (key in config) {
          val = config[key];
          this.config[key] = !!val;
        }
      }
      _ref = this.getInfo(), objects = _ref[0], classes = _ref[1];
      this.classes = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          clss = classes[_i];
          _results.push(this.getDataOfClass(clss));
        }
        return _results;
      }).call(this);
      this.relations = this.getRelations();
      this.svgId = "__uml_svg";
      this.canvasId = "__uml_canvas";
      this.svg = $("<svg id='" + this.svgId + "' width='10000' height='7000'><g /></svg>");
      $(document.body).append(this.svg);
      this.draw();
    }

    UMLClassDiagram.prototype.getType = function(val) {
      var type, _ref;
      if ((val != null) && (((_ref = val.constructor) != null ? _ref.name : void 0) != null)) {
        if ((type = val.constructor.name) === "Array") {
          return this.getTypeOfArray(val);
        }
        return type;
      }
      return typeof val;
    };

    UMLClassDiagram.prototype.getTypeOfArray = function(arr) {
      var elem, prevType, _i, _len;
      if (arr.length > 0) {
        prevType = this.getType(arr[0]);
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          elem = arr[_i];
          if (this.getType(elem) !== prevType) {
            return "Mixed array";
          }
        }
        return "Array of " + prevType;
      }
      return "Array";
    };

    UMLClassDiagram.prototype.parseArguments = function(funcStr) {
      var signature;
      signature = funcStr.slice(funcStr.indexOf("function") + 8, funcStr.indexOf("{")).trim();
      return signature.slice(1, signature.lastIndexOf(")", 1));
    };

    UMLClassDiagram.prototype.getDataOfClass = function(clss) {
      var attributes, e, k, key, methods, obj, objs, res, retType, v, val;
      attributes = [];
      methods = [];
      try {
        obj = new clss();
      } catch (_error) {
        e = _error;
        return {
          name: null,
          attributes: [],
          methods: [],
          superClass: null
        };
      }
      for (key in obj) {
        val = obj[key];
        if (typeof val === "function") {
          retType = null;
          if (this.config.returnTypes === true) {
            try {
              retType = this.getType(val());
            } catch (_error) {
              e = _error;
              console.log(e);
            }
          }
          if (key !== "__uml_init" && key !== "constructor") {
            methods.push({
              name: key,
              returnType: retType,
              "arguments": this.config["arguments"] === true ? this.parseArguments(val.toString()) : []
            });
          } else if (key === "__uml_init") {
            objs = val();
            res = [];
            for (k in objs) {
              v = objs[k];
              attributes.push({
                name: k,
                type: v.constructor.name
              });
            }
          }
        } else {
          attributes.push({
            name: key,
            type: this.getType(val)
          });
        }
      }
      return {
        name: clss.name,
        attributes: this.config.attributes === true ? attributes : [],
        methods: this.config.methods === true ? methods : [],
        superClass: clss.__super__ == null ? null : clss.__super__.constructor.name
      };
    };

    UMLClassDiagram.prototype.getInfo = function() {
      var classes, getInfoRec, inDOM, objs;
      objs = [];
      classes = [];
      inDOM = function(obj) {
        if (typeof Node === "object") {
          return obj instanceof Node;
        }
        return typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
      };
      getInfoRec = function(obj) {
        var ctor, key, keys, name, val, _i, _len, _results;
        if (inDOM(obj)) {
          return;
        }
        keys = Object.keys(obj);
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          val = obj[key];
          if (val != null) {
            if (typeof val === "object" && __indexOf.call(objs, val) < 0) {
              objs.push(val);
              _results.push(getInfoRec(val));
            } else if (typeof val === "function") {
              if (((name = val.name) != null) && (name.length != null) && name.length > 2 && __indexOf.call(IGNORED_CLASSES, name) < 0 && __indexOf.call(classes, val) < 0) {
                _results.push(classes.push(val));
              } else if (((name = (ctor = val.constructor).name) != null) && name !== "" && __indexOf.call(IGNORED_CLASSES, name) < 0) {
                _results.push(classes.push(ctor));
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      getInfoRec(window);
      return [objs, classes];
    };

    UMLClassDiagram.prototype.getRelations = function() {
      var attr, attrType, classNames, clss, relations, types, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (this.classes != null) {
        classNames = (function() {
          var _i, _len, _ref, _results;
          _ref = this.classes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            clss = _ref[_i];
            _results.push(clss.name);
          }
          return _results;
        }).call(this);
        relations = {};
        _ref = this.classes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          clss = _ref[_i];
          relations[clss.name] = {};
          types = relations[clss.name];
          _ref1 = clss.attributes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            attr = _ref1[_j];
            attrType = attr.type;
            if (__indexOf.call(classNames, attrType) >= 0) {
              if (types[attrType] == null) {
                types[attrType] = 1;
              } else {
                types[attrType]++;
              }
            } else if (attrType.substr(0, 8) === "Array of") {
              if (_ref2 = (attrType = attrType.substring(9)), __indexOf.call(IGNORED_CLASSES, _ref2) < 0) {
                types[attrType] = Infinity;
              }
            }
          }
        }
        return relations;
      }
      return {};
    };

    UMLClassDiagram.prototype.generateLabel = function(cardinality) {
      return "" + (cardinality === Infinity ? "*" : cardinality);
    };

    UMLClassDiagram.prototype.getClassByName = function(clssName) {
      var clss, _i, _len, _ref;
      _ref = this.classes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        clss = _ref[_i];
        if (clss.name === clssName) {
          return clss;
        }
      }
      return null;
    };

    UMLClassDiagram.prototype.isInheritance = function(source, target) {
      return this.getClassByName(source).superClass === target;
    };

    UMLClassDiagram.prototype.draw = function() {
      var attribute, clss, clssName, count, defs, e, edge, g, i, idx, item, key, label, line, maxChars, method, renderer, sep, svg, to, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      g = new dagre.Digraph();
      _ref = this.classes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        clss = _ref[_i];
        if (clss.name == null) {
          continue;
        }
        label = [];
        line = "";
        sep = "__";
        item = "" + clss.name;
        label.push(item);
        maxChars = item.length;
        label.push(sep);
        if (this.config.attributes === true) {
          _ref1 = clss.attributes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            attribute = _ref1[_j];
            if (this.config.types === true) {
              item = "" + attribute.name + " : " + attribute.type;
            } else {
              item = "" + attribute.name;
            }
            label.push(item);
            maxChars = maxChars > item.length ? maxChars : item.length;
          }
        }
        label.push(sep, "\n");
        if (this.config.methods === true) {
          _ref2 = clss.methods;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            method = _ref2[_k];
            if (this.config.returnTypes === true) {
              item = "" + method.name + "(" + (this.config["arguments"] === true ? method["arguments"] : "") + ") : " + method.returnType;
            } else {
              item = "" + method.name + "(" + (this.config["arguments"] === true ? method["arguments"] : "") + ")";
            }
            label.push(item);
            maxChars = maxChars > item.length ? maxChars : item.length;
          }
        }
        for (i = _l = 0; 0 <= maxChars ? _l <= maxChars : _l >= maxChars; i = 0 <= maxChars ? ++_l : --_l) {
          line += "_";
        }
        for (i = _m = 0, _len3 = label.length; _m < _len3; i = ++_m) {
          item = label[i];
          if (item === sep) {
            label[i] = line;
          }
        }
        label = label.join("\n");
        g.addNode(clss.name, {
          label: label
        });
      }
      _ref3 = this.relations;
      for (clssName in _ref3) {
        edge = _ref3[clssName];
        for (to in edge) {
          count = edge[to];
          try {
            if (this.config.cardinalities === true) {
              g.addEdge(null, clssName, to, {
                label: "" + (this.generateLabel(count))
              });
            } else {
              g.addEdge(null, clssName, to);
            }
          } catch (_error) {
            e = _error;
            console.log(e);
          }
        }
      }
      _ref4 = this.classes;
      for (_n = 0, _len4 = _ref4.length; _n < _len4; _n++) {
        clss = _ref4[_n];
        if (clss.superClass != null) {
          try {
            g.addEdge(null, clss.name, clss.superClass, {
              inheritance: true
            });
          } catch (_error) {
            e = _error;
            console.log(e);
          }
        }
      }
      renderer = new dagreD3.Renderer();
      svg = d3.select("#" + this.svgId + " g");
      renderer.layout(dagreD3.layout().rankDir("BT")).run(g, svg);
      defs = d3.select("defs");
      console.log(defs);
      defs.html(defs.html() + "<marker id='subclass' viewBox='0 0 10 10' refX='8' refY='5' markerUnits='strokeWidth' markerWidth='10' markerHeight='10' orient='auto' style='fill: #fff' stroke='#000' stroke-width='1'><path d='M 0 0 L 10 5 L 0 10 z' /></marker>");
      idx = 0;
      _ref5 = g._edges;
      for (key in _ref5) {
        edge = _ref5[key];
        if (this.isInheritance(edge.u, edge.v) || this.isInheritance(edge.v, edge.u)) {
          this.svg.find(".edgePath").eq(idx).find("path").attr("marker-end", "url(#subclass)");
        }
        idx++;
      }
      this.svg.css({
        "overflow": "hidden",
        "font-family": "courier"
      });
      this.svg.find(".node rect").css({
        "stroke": "#333",
        "stroke-width": "1.5px",
        "fill": "#fff"
      });
      this.svg.find(".edgeLabel rect").css({
        "fill": "#fff"
      });
      this.svg.find(".edgePath").css({
        "stroke": "#333",
        "stroke-width": "1.5px",
        "fill": "none"
      });
      return this;
    };

    UMLClassDiagram.prototype["export"] = function() {
      var svgString, xml;
      if (typeof XMLSerializer !== "undefined" && XMLSerializer !== null) {
        this.canvas = $("<canvas id='" + this.canvasId + "' />");
        $(document.body).append(this.canvas);
        xml = new XMLSerializer();
        svgString = xml.serializeToString(this.svg[0]);
        canvg(this.canvasId, svgString, {
          ignoreMouse: true,
          ignoreAnimation: true
        });
      }
      return this;
    };

    return UMLClassDiagram;

  })();

}).call(this);
