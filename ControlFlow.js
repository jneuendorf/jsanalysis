// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.ControlFlowDiagram = (function() {
    var CSS, IGNORED_CLASSES, IGNORED_FUNCTIONS, IGNORED_GLOBAL_KEYS, makeNode;

    IGNORED_GLOBAL_KEYS = ["top", "dagre", "dagreD3", "d3"];

    IGNORED_FUNCTIONS = ["Window.$", "Window.RGBColor", "Window.stackBlurImage", "Window.stackBlurCanvasRGBA", "Window.stackBlurCanvasRGB", "Window.BlurStack", "Window.canvg", "Window.UMLClassDiagram", "Window.ControlFlowDiagram", "$", "document.createDocumentFragment", "document.createElement", "removeEventListener"];

    IGNORED_CLASSES = ["ControlFlowDiagram", "RGBColor", "stackBlurImage", "UMLClassDiagram", "g", "BlurStack", "stackBlurCanvasRGBA", "stackBlurCanvasRGB"];

    CSS = function(id) {
      return "#" + id + " {\n	overflow: hidden;\n	font-family: courier;\n}\n\n#" + id + " .node rect {\n	stroke: #333;\n	stroke-width: 1.5px;\n	/*fill: #fff;*/\n}\n\n#" + id + " .edgeLabel rect {\n	fill: #fff;\n}\n\n#" + id + " .edgePath {\n	stroke: #333;\n	stroke-width: 1.5px;\n	fill: none;\n}";
    };

    function ControlFlowDiagram(config) {
      this.config = {
        drawAfterCalls: 10000,
        drawAfterTime: 3000
      };
      this.listening = true;
      this.calls = 0;
      this.nodes = [];
      this.objs = [];
      this.scopes = [];
      this.svgId = "__ControlFlow_svg";
      this.svg = $("<svg id='" + this.svgId + "' width='10000' height='7000'><g /></svg>");
      $(document).ready((function(_this) {
        return function() {
          $(document.body).append(_this.svg);
          return _this.createCSSStyle(CSS(_this.svgId));
        };
      })(this));
      this.start = Date.now();
      this.decorateFunctions();
      window.__ControlFlow_obj = this;
    }

    ControlFlowDiagram.prototype.createCSSStyle = function(cssStr) {
      var style;
      style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = cssStr;
      document.head.appendChild(style);
      return this;
    };

    makeNode = function(n, ref, p, c) {
      if (n == null) {
        n = "";
      }
      if (ref == null) {
        ref = null;
      }
      if (p == null) {
        p = [];
      }
      if (c == null) {
        c = [];
      }
      return {
        name: n,
        funcRef: ref,
        parents: p,
        children: c,
        calls: 1,
        visited: false
      };
    };

    ControlFlowDiagram.prototype.getNode = function(funcRef) {
      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.funcRef === funcRef) {
          return node;
        }
      }
      return null;
    };

    ControlFlowDiagram.prototype.addNode = function(node) {
      this.nodes.push(node);
      return this;
    };

    ControlFlowDiagram.prototype.getInfo = function() {
      var classes, getInfoRec, i, inDOM, objs, scope, scopes, visited, _i, _len;
      objs = [];
      scopes = [];
      classes = [];
      visited = [];
      inDOM = function(obj) {
        if (typeof Node === "object") {
          return obj instanceof Node;
        }
        return typeof obj === "object" && typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
      };
      getInfoRec = function(scope, obj, scopeName) {
        var key, keys, name, val, _i, _len, _results;
        if (inDOM(obj)) {
          return;
        }
        keys = Object.keys(obj);
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          if (__indexOf.call(IGNORED_GLOBAL_KEYS, key) < 0 && isNaN(key)) {
            if ((val = obj[key]) != null) {
              if (typeof val === "object" && __indexOf.call(objs, val) < 0) {
                objs.push(val);
                scopes.push("" + scopeName + "." + key);
                _results.push(getInfoRec(obj, val, "" + scopeName + "." + key));
              } else if (typeof val === "function") {
                if (((name = val.name) != null) && (name.length != null) && name.length > 2 && __indexOf.call(IGNORED_CLASSES, name) < 0 && __indexOf.call(visited, val) < 0) {
                  classes.push({
                    ctor: val,
                    scope: scope
                  });
                  _results.push(visited.push(val));
                } else {
                  _results.push(void 0);
                }
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          }
        }
        return _results;
      };
      getInfoRec(window, window, "");
      for (i = _i = 0, _len = scopes.length; _i < _len; i = ++_i) {
        scope = scopes[i];
        scopes[i] = scope.slice(8);
      }
      return [objs, classes, scopes];
    };

    ControlFlowDiagram.prototype.parseArguments = function(funcStr) {
      var signature;
      signature = funcStr.slice(funcStr.indexOf("("), funcStr.indexOf("{")).trim();
      return signature.slice(1, signature.lastIndexOf(")", 1));
    };

    ControlFlowDiagram.prototype.registerCall = function(funName, currentFunc, callingFunc) {
      var helper;
      helper = (function(_this) {
        return function(funName, currentFunc, callingFunc) {
          var newNode, node, parentNode;
          node = _this.getNode(currentFunc);
          parentNode = _this.getNode(callingFunc);
          if (node != null) {
            node.calls++;
            if ((parentNode != null) && __indexOf.call(parentNode.children, node) < 0) {
              parentNode.children.push(node);
              node.parents.push(parentNode);
            }
          } else {
            newNode = makeNode(funName, currentFunc);
            _this.addNode(newNode);
            if (parentNode != null) {
              newNode.parents.push(parentNode);
              parentNode.children.push(newNode);
            }
          }
          return _this;
        };
      })(this);
      if (this.listening === true) {
        if (this.calls++ < this.config.drawAfterCalls && Date.now() - this.start < this.config.drawAfterTime) {
          return helper(funName, currentFunc, callingFunc);
        }
        this.listening = false;
        return this.draw();
      }
    };

    ControlFlowDiagram.prototype.decorateFunctions = function() {
      var classNames, classes, clss, ctor, funName, i, item, key, methodName, obj, objs, org, orgMethod, scope, scopeName, scopes, self, val, visited, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.getInfo(), objs = _ref[0], classes = _ref[1], scopes = _ref[2];
      this.objs = objs;
      this.scopes = scopes;
      visited = [];
      self = this;
      classNames = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          clss = classes[_i];
          _results.push(clss.ctor.name);
        }
        return _results;
      })();
      for (_i = 0, _len = objs.length; _i < _len; _i++) {
        obj = objs[_i];
        for (key in obj) {
          val = obj[key];
          if (__indexOf.call(classNames, key) >= 0) {
            continue;
          }
          if (typeof val === "function" && __indexOf.call(visited, val) < 0) {
            visited.push(val);
            scopeName = this.scopes[this.objs.indexOf(obj)];
            if (scopeName !== "") {
              funName = "" + scopeName + "." + key;
            } else {
              funName = key;
            }
            if (__indexOf.call(IGNORED_FUNCTIONS, funName) >= 0) {
              continue;
            }
            org = val;
            obj[key] = (function(funName, org) {
              return function() {
                self.registerCall(funName, org, arguments.callee.caller);
                return org.apply(this, arguments);
              };
            })(funName, org);
          }
        }
      }
      for (i = _j = 0, _len1 = classes.length; _j < _len1; i = ++_j) {
        item = classes[i];
        ctor = item.ctor;
        scope = item.scope;
        _ref1 = ctor.prototype;
        for (methodName in _ref1) {
          orgMethod = _ref1[methodName];
          if (!(methodName !== "constructor")) {
            continue;
          }
          funName = "" + ctor.name + "." + methodName;
          ctor.prototype[methodName] = (function(funName, orgMethod) {
            return function() {
              self.registerCall(funName, orgMethod, arguments.callee.caller);
              return orgMethod.apply(this, arguments);
            };
          })(funName, orgMethod);
        }
        funName = "new " + ctor.name + "()";
        org = ctor;
        classes[i] = (function(funName, ctor, scope) {
          var code, fun, funcStr, prot;
          funcStr = ctor.toString();
          code = "return function " + ctor.name + "(" + (self.parseArguments(funcStr)) + ") {\n	// console.log(\"wrapper - kind: constructor\", \"" + funName + "\");\n	__ControlFlow_obj.registerCall(\"" + funName + "\", ctor, arguments.callee.caller);\n	ctor.apply(this, arguments);\n}";
          fun = (new Function("ctor", code))(ctor);
          for (methodName in ctor) {
            orgMethod = ctor[methodName];
            if (!(methodName !== "__super__")) {
              continue;
            }
            funName = "" + ctor.name + "::" + methodName;
            fun[methodName] = (function(funName, orgMethod) {
              return function() {
                self.registerCall(funName, orgMethod, arguments.callee.caller);
                return orgMethod.apply(this, arguments);
              };
            })(funName, orgMethod);
          }
          prot = ctor.prototype;
          prot.constructor = fun;
          scope[ctor.name] = fun;
          scope[ctor.name].prototype = prot;
          return fun;
        })(funName, ctor, scope);
      }
      return this;
    };

    ControlFlowDiagram.prototype.getColorForNode = function(calls) {
      var n;
      n = Math.round((calls / this.calls) * 255);
      return "rgb(255," + (255 - n) + "," + (255 - n) + ")";
    };

    ControlFlowDiagram.prototype.draw = function() {
      var addedEgdes, edge, edgesToAdd, g, i, makeGraph, node, oldDrawNodes, renderer, self, svg, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      self = this;
      console.log("drawing", this.listening);
      g = new dagre.Digraph();
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        node.visited = false;
      }
      addedEgdes = [];
      edgesToAdd = [];
      makeGraph = (function(_this) {
        return function(node) {
          var child, edgeName, _j, _len1, _ref1, _ref2, _results;
          if (node.visited === false) {
            g.addNode(node.name, {
              label: node.name,
              color: _this.getColorForNode(node.calls)
            });
            node.visited = true;
          }
          _ref1 = node.children;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            child = _ref1[_j];
            if (!(_ref2 = (edgeName = node.name + child.name), __indexOf.call(addedEgdes, _ref2) < 0)) {
              continue;
            }
            makeGraph(child);
            edgesToAdd.push(node.name, child.name);
            _results.push(addedEgdes.push(edgeName));
          }
          return _results;
        };
      })(this);
      _ref1 = this.nodes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        node = _ref1[_j];
        makeGraph(node);
      }
      for (i = _k = 0, _len2 = edgesToAdd.length; _k < _len2; i = _k += 2) {
        edge = edgesToAdd[i];
        g.addEdge(null, edge, edgesToAdd[i + 1]);
      }
      console.log(g);
      renderer = new dagreD3.Renderer();
      oldDrawNodes = renderer.drawNodes();
      renderer.drawNodes(function(graph, svg) {
        var rect, svgNode, svgNodes, _l, _len3, _ref2;
        svgNodes = oldDrawNodes(graph, svg);
        _ref2 = svgNodes[0];
        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
          svgNode = _ref2[_l];
          rect = d3.select(svgNode).select("rect");
          rect.attr("fill", graph._nodes[svgNode.__data__].value.color);
        }
        console.log(svgNodes);
        return svgNodes;
      });
      svg = d3.select("#" + this.svgId + " g");
      renderer.layout(dagreD3.layout().rankDir("LR")).run(g, svg);
      return this;
    };

    return ControlFlowDiagram;

  })();

}).call(this);
